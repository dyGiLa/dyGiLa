// File generated by hilapp at Wed Mar  9 09:30:49 2022
// Git version: e3ba0735
// cmd: ../../HILA/hila/hilapp/bin/hilapp -I/opt/shared/openmpi/1.8.2/include 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/include/c++/9.3.0 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/../../../../include/c++/9.3.0/x86_64-pc-linux-gnu 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/../../../../include/c++/9.3.0/backward 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/include 
//        -I/usr/local/include -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/include 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/include-fixed 
//        -I/usr/include -I/opt/shared/openmpi/1.8.2/include -I/opt/shared/fftw/3.3.2/include/ 
//        -DUSE_MPI -I../../HILA/hila/hilapp/clang_include -DNDIM=3 
//        -DUSE_MPI -I/opt/shared/fftw/3.3.2/include/ -I../../HILA/hila/libraries 
//        -I../../HILA/hila/libraries/plumbing -DGIT_SHA_VALUE=ee2789b8 
//        ../../HILA/hila/libraries/plumbing/input.cpp -o build/input.cpt 
//        

#include <sstream>
#include <iostream>
#include <fstream>
#include <regex>
#include <type_traits>
// start include "defs.h"---------------------------------
#ifndef DEFS_H_
#define DEFS_H_

// This gives us math constants, e.g. M_PI etc.
#define _USE_MATH_DEFINES

// Useful global definitions here -- this file should be included by (almost) all others

#include <iostream>
#include <array>
#include <vector>
#include <assert.h>
#include <sstream>
// #include <math.h>
#include <type_traits>
#include <cmath>


#ifdef USE_MPI
#ifdef HILAPP
// Removed by hilapp"/cluster/home/alopez07/HILA/hila/libraries/plumbing/hilapp_mpi.h"
#else
#include <mpi.h>
#endif
#endif

// Read in Makefile tunable parameters first
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/params.h"

#ifdef HILAPP
// Removed by hilapp
#endif

#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/mersenne.h"
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/memalloc.h" // memory allocator
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/timing.h"


/// Define __restrict__?  It is non-standard but supported by most (all?) compilers.
/// ADD HERE GUARD FOR THOSE WHICH DO not HAVE IT
#define RESTRICT __restrict__
// #ifndef CUDA
// #define RESTRICT __restrict__
// #else
// #define RESTRICT // disabled here
// #endif


// This below declares "out_only" -qualifier.  It is empty on purpose. Do not remove!
#define out_only
// out_only for methods tells hilapp that the base variable original value is not
// needed: class C {
//    int set() out_only { .. }
// };
// indicates that a.set(); does not need original value of a.
// Can also be used in function arguments:
//    int func( out_only double & p, ..);

// Defined empty on purpose, same as above!
#define const_function
// const_function does not change the base variable, but can return a (non-const)
// reference. Needed typically for access operators for loop extern variables:
//     class v {
//         double c[N];
//         double & e(const int i) const_function { return c[i]; }
//     };
//
//     v vv;
//     Field<v>  f;
//     onsites(ALL) { f[X].e(0) += vv.e(0); }
// This would not work without const_function, because vv.e(1) might modify loop
// extern variable vv, which is not allowed.  If method is marked "const",
// then the assignment would not work.
//
// const_function is weaker than const.


// text output section -- defines also output0, which writes from node 0 only
namespace hila {

/// this is our default output file stream
extern std::ostream output;
/// this is just a hook to store output file, if it is in use
extern std::ofstream output_file;

// about_to_finish becomes true at the end.  Signals that
// better not rely on MPI or existence of objects any more.
extern bool about_to_finish;

// check_input is used to notify that we're just checking the
// input values and will exit before fields are allocated.
extern bool check_input;
extern int check_with_nodes;

// optional input filename
extern const char *input_file;

void initialize(int argc, char **argv);
void finishrun();
void terminate(int status);
void error(const std::string &msg);
void error(const char *msg);


/// rank of this node
int myrank();
/// how many nodes there are
int number_of_nodes();
/// synchronize mpi
void synchronize();


} // namespace hila

// The logger uses hila::myrank, so it cannot be included on top
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/logger.h"
namespace hila {
/// Now declare the logger
extern logger_class log;
} // namespace hila

/// We want to define ostream
///     "output0 << stuff;"
/// which is done only by rank 0.
/// This is hacky but easy.  Probably should be done without #define.
/// Do this through else-branch in order to avoid if-statement problems.
/// #define output0 if (hila::myrank() != 0) {} else hila::output
///
/// Above #define can trigger "dangling-else" warning.  Let us
/// try to avoid it with the following a bit more ugly trick:
#define output0                                                                        \
    for (int _dummy_i_ = 1; hila::myrank() == 0 && _dummy_i_; --_dummy_i_)             \
    hila::output

// The following disables the "dangling-else" warning, but not needed now
//#if defined(__clang__) || defined(__GNUC__)
//#pragma GCC diagnostic ignored "-Wdangling-else"
//#endif

/// define a class for FFT direction
enum class fft_direction { forward, back };

// trivial template for helping vectorization
template <typename T>
using element = T;

// Backend defs-headers

#if defined(CUDA) || defined(HIP)
#include "plumbing/backend_cuda/defs.h"
#elif defined(AVX)
#include "plumbing/backend_vector/defs.h"
#else
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/backend_cpu/defs.h"
#endif

// this include has to be after the backend defs, because those define hila::random()
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/random.h"

// This contains useful template tools
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/type_tools.h"

#if defined(CUDA) || defined(HIP)
#include "plumbing/backend_cuda/cuda_templated_ops.h"
#endif

// Include some basic functions for real (non-class) vars,
// to help with generic code
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/real_var_ops.h"

// MPI Related functions and definitions
#define MAX_GATHERS 1000

#ifndef USE_MPI

// broadcast does nothing if not MPI
template <typename T>
void broadcast(T &v) {}

template <typename T>
void broadcast_array(T *var, int n) {}

#endif

void initialize_communications(int &argc, char ***argv);
void split_into_sublattices(int rank);
bool is_comm_initialized(void);
void finish_communications();
void abort_communications(int status);

// and print a dashed line
void print_dashed_line(const std::string &txt = {});


#endif
// end include "defs.h"---------------------------------

#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/input.h"
#include <errno.h>
#include <iomanip>

#define COMMENT_CHAR '#'

//////////////////////////////////////////////////////////////////////////////
/// Parameter file input system
/// Check input.h for user instructions
//////////////////////////////////////////////////////////////////////////////

namespace hila {

static std::string empty_key("");

bool input::open(const std::string &file_name, bool use_cmdline, bool exit_on_error) {
    extern const char *input_file;

    std::string fname;

    if (use_cmdline && input_file != nullptr) {

        fname = input_file;
        input_file = nullptr; // set this null, so that it is not used again
    } else {
        fname = file_name;
    }

    bool got_error = false;
    if (hila::myrank() == 0) {
        if (is_initialized) {
            if (speaking)
                hila::output << "Error: file '" << fname
                             << "' cannot be opened because '" << filename
                             << "' is open in this input variable\n";

            got_error = true;
        } else {
            filename = fname;
            if (fname == "-") {
                use_cin = true;
                if (speaking)
                    print_dashed_line("Reading from standard input");
            } else {
                use_cin = false;
                inputfile.open(fname);
                if (inputfile.is_open()) {
                    is_initialized = true;

                    if (speaking)
                        print_dashed_line("Reading file " + filename);

                } else {

                    if (speaking)
                        hila::output << "Error: input file '" << fname
                                     << "' could not be opened\n";

                    got_error = true;
                }
            }
        }
    }
    broadcast(got_error);
    if (got_error && exit_on_error) {
        hila::finishrun();
    }

    return !got_error;
}

void input::close() {
    if (is_initialized && !use_cin) {
        inputfile.close();
        is_initialized = false;
    }
    if (speaking)
        print_dashed_line();

    // automatic cleaning of other vars
}

// read one line skipping comments and initial whitespace
bool input::get_line() {
    if (hila::myrank() == 0) {
        do {
            std::istream *inptr;

            if (use_cin)
                inptr = &std::cin;
            else
                inptr = &inputfile;

            *inptr >> std::ws; // remove initial whitespace
            if (!std::getline(*inptr, linebuffer)) {
                linebuffer.clear();
                lb_start = 0;
                return false;
            }
        } while (linebuffer.at(0) == COMMENT_CHAR);
        size_t i = linebuffer.find(COMMENT_CHAR);
        if (i != std::string::npos)
            linebuffer.resize(i);
        lb_start = 0;

        is_line_printed = false; // not yet printed
    }
    return true; // sync this at another spot
}

// print the read-in line with a bit special formatting
void input::print_linebuf(int end_of_key) {
    if (hila::myrank() == 0 && speaking) {

        if (is_line_printed)
            return;
        is_line_printed = true;

        int i = 0;
        while (std::isspace(linebuffer[i]))
            i++;
        for (; i < linebuffer.size() && i < end_of_key; i++) {
            hila::output << linebuffer[i];
        }
        hila::output << ' ';
        if (end_of_key > 0) {
            for (int j = i; j < 20; j++)
                hila::output << ' ';
        }

        while (i < linebuffer.size() && std::isspace(linebuffer[i]))
            i++;
        if (i < linebuffer.size()) {
            hila::output << linebuffer.substr(i);
        }
        hila::output << '\n';
    }
}

// remove leading whitespace, incl. lines
bool input::remove_whitespace() {
    if (hila::myrank() == 0) {
        while (lb_start < linebuffer.size() && std::isspace(linebuffer[lb_start]))
            lb_start++;
        if (lb_start == linebuffer.size())
            return get_line();
    }
    return true; // do not broadcast yet, should be used only in node 0
}

// returns true if line contains the word list at the beginning of line.  list
// contains the word separated by whitespace.  If match found, advances the
// lb_start to new position.  end_of_key is the index where key match on line ends

bool input::contains_word_list(const std::string &list, int &end_of_key) {
    const char *p = linebuffer.c_str() + lb_start;
    const char *q = list.c_str();
    while (std::isspace(*p))
        p++;
    while (std::isspace(*q))
        q++;

    while (*p && *q) {
        // compare non-space chars
        while (*p && *q && *p == *q && !std::isspace(*q)) {
            p++;
            q++;
        }
        if (std::isspace(*q) && std::isspace(*p)) {
            // matching spaces, skip
            while (std::isspace(*p))
                p++;
            while (std::isspace(*q))
                q++;
        }

        if (*p != *q)
            break;
    }
    // if line contained the words in list, *q = 0.
    while (std::isspace(*q))
        q++;
    if (*q != 0)
        return false;

    end_of_key = p - linebuffer.c_str();

    while (std::isspace(*p))
        p++;
    lb_start = p - linebuffer.c_str();
    return true;
}

// find tokens separated by whitespace or ,
// inside of " .. " is one token too.
// returns true if the next token (on the same line) is found

bool input::peek_token(std::string &tok) {
    if (!remove_whitespace())
        return false;
    size_t i;
    bool in_quotes = false;
    for (i = lb_start;
         i < linebuffer.size() &&
         ((!std::isspace(linebuffer[i]) && linebuffer[i] != ',') || in_quotes);
         i++) {
        if (linebuffer[i] == '"') {
            in_quotes = !in_quotes;
        }
    }
    if (i == lb_start && linebuffer[i] == ',')
        i++; // this happens for only ,

    if (in_quotes) {
        hila::output << "Error: unbalanced quotes\n";
        exit(1); // unclean exit
    }
    tok = linebuffer.substr(lb_start, i - lb_start);
    return true;
}

// consumes the token too

bool input::get_token(std::string &tok) {
    if (peek_token(tok)) {
        lb_start += tok.size();
        return true;
    }
    return false;
}

// match_token returns true and consumes the token if it matches the argument

bool input::match_token(const std::string &tok) {
    std::string s;
    if (peek_token(s) && s == tok) {
        lb_start += tok.size();
        return true;
    }
    return false;
}

// require the (typically beginning of line) key for parameters

bool input::handle_key(const std::string &key) {
    if (hila::myrank() == 0) {
        // check the linebuffer for stuff
        remove_whitespace();

        int end_of_key = 0;
        if (key.size() > 0 && !contains_word_list(key, end_of_key)) {
            if (speaking) {
                print_linebuf(0);
                hila::output << "Error: expecting key '" << key << "'\n";
            }
            return false;
        }

        print_linebuf(end_of_key);
    }
    return true;
}

// is the input string int/double/string and return it


// a trivial function, useful for template
bool input::is_value(const std::string &str, std::string &val) {
    val = remove_quotes(str);
    return true;
}

std::string input::remove_quotes(const std::string &val) {
    size_t i, j;
    std::string res;
    res = val;
    for (j = i = 0; i < val.size(); i++)
        if (val[i] != '"')
            res[j++] = val[i];
    res.resize(j);
    return res;
}

//  expects "label   <item>"  -line, where <item> matches one of the std::strings in
//  items. returns the index of the item. If not found, errors out

int input::get_item(const std::string &label, const std::vector<std::string> &items,
                    bool bcast) {

    bool no_error = handle_key(label);
    int item = -1;
    double d;
    std::string s;

    if (hila::myrank() == 0) {
        if (no_error && peek_token(s)) {

            for (int i = 0; i < items.size() && item < 0; i++) {
                double dval;
                long lval;
                int end_of_key;

                // clang-format off
                if ((items[i] == "%s") ||
                    (items[i] == "%f" && is_value(s,dval)) ||
                    (items[i] == "%i" && is_value(s,lval)) ||
                    contains_word_list(items[i],end_of_key)) {
                    item = i;
                }
                // clang-format on
            }
        }

        if (item < 0) {
            // error, nothing was found
            no_error = false;
            if (speaking) {
                hila::output << "Input '" << label << "' must be one of: ";
                for (int i = 0; i < items.size(); i++) {
                    if (items[i] == "%s")
                        hila::output << "<string> ";
                    else if (items[i] == "%f")
                        hila::output << "<float/double> ";
                    else if (items[i] == "%i")
                        hila::output << "<int/long> ";
                    else
                        hila::output << '\'' << items[i] << "' ";
                }
                hila::output << '\n';
            }
        }
    }

    if (bcast) {
        broadcast(item, no_error);

        // with broadcast exit on error
        if (!no_error)
            hila::finishrun();
    }

    return item;
}

} // namespace hila
