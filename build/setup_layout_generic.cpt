// File generated by hilapp at Wed Mar  9 09:31:11 2022
// Git version: e3ba0735
// cmd: ../../HILA/hila/hilapp/bin/hilapp -I/opt/shared/openmpi/1.8.2/include 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/include/c++/9.3.0 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/../../../../include/c++/9.3.0/x86_64-pc-linux-gnu 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/../../../../include/c++/9.3.0/backward 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/include 
//        -I/usr/local/include -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/include 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/include-fixed 
//        -I/usr/include -I/opt/shared/openmpi/1.8.2/include -I/opt/shared/fftw/3.3.2/include/ 
//        -DUSE_MPI -I../../HILA/hila/hilapp/clang_include -DNDIM=3 
//        -DUSE_MPI -I/opt/shared/fftw/3.3.2/include/ -I../../HILA/hila/libraries 
//        -I../../HILA/hila/libraries/plumbing -DGIT_SHA_VALUE=ee2789b8 
//        ../../HILA/hila/libraries/plumbing/setup_layout_generic.cpp 
//        -o build/setup_layout_generic.cpt 

/// Setup layout does the node division.  This version
/// first tries an even distribution, with equally sized
/// nodes, and if that fails allows slightly different
/// node sizes.

// start include "plumbing/defs.h"---------------------------------
#ifndef DEFS_H_
#define DEFS_H_

// This gives us math constants, e.g. M_PI etc.
#define _USE_MATH_DEFINES

// Useful global definitions here -- this file should be included by (almost) all others

#include <iostream>
#include <array>
#include <vector>
#include <assert.h>
#include <sstream>
// #include <math.h>
#include <type_traits>
#include <cmath>


#ifdef USE_MPI
#ifdef HILAPP
// Removed by hilapp"/cluster/home/alopez07/HILA/hila/libraries/plumbing/hilapp_mpi.h"
#else
#include <mpi.h>
#endif
#endif

// Read in Makefile tunable parameters first
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/params.h"

#ifdef HILAPP
// Removed by hilapp
#endif

#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/mersenne.h"
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/memalloc.h" // memory allocator
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/timing.h"


/// Define __restrict__?  It is non-standard but supported by most (all?) compilers.
/// ADD HERE GUARD FOR THOSE WHICH DO not HAVE IT
#define RESTRICT __restrict__
// #ifndef CUDA
// #define RESTRICT __restrict__
// #else
// #define RESTRICT // disabled here
// #endif


// This below declares "out_only" -qualifier.  It is empty on purpose. Do not remove!
#define out_only
// out_only for methods tells hilapp that the base variable original value is not
// needed: class C {
//    int set() out_only { .. }
// };
// indicates that a.set(); does not need original value of a.
// Can also be used in function arguments:
//    int func( out_only double & p, ..);

// Defined empty on purpose, same as above!
#define const_function
// const_function does not change the base variable, but can return a (non-const)
// reference. Needed typically for access operators for loop extern variables:
//     class v {
//         double c[N];
//         double & e(const int i) const_function { return c[i]; }
//     };
//
//     v vv;
//     Field<v>  f;
//     onsites(ALL) { f[X].e(0) += vv.e(0); }
// This would not work without const_function, because vv.e(1) might modify loop
// extern variable vv, which is not allowed.  If method is marked "const",
// then the assignment would not work.
//
// const_function is weaker than const.


// text output section -- defines also output0, which writes from node 0 only
namespace hila {

/// this is our default output file stream
extern std::ostream output;
/// this is just a hook to store output file, if it is in use
extern std::ofstream output_file;

// about_to_finish becomes true at the end.  Signals that
// better not rely on MPI or existence of objects any more.
extern bool about_to_finish;

// check_input is used to notify that we're just checking the
// input values and will exit before fields are allocated.
extern bool check_input;
extern int check_with_nodes;

// optional input filename
extern const char *input_file;

void initialize(int argc, char **argv);
void finishrun();
void terminate(int status);
void error(const std::string &msg);
void error(const char *msg);


/// rank of this node
int myrank();
/// how many nodes there are
int number_of_nodes();
/// synchronize mpi
void synchronize();


} // namespace hila

// The logger uses hila::myrank, so it cannot be included on top
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/logger.h"
namespace hila {
/// Now declare the logger
extern logger_class log;
} // namespace hila

/// We want to define ostream
///     "output0 << stuff;"
/// which is done only by rank 0.
/// This is hacky but easy.  Probably should be done without #define.
/// Do this through else-branch in order to avoid if-statement problems.
/// #define output0 if (hila::myrank() != 0) {} else hila::output
///
/// Above #define can trigger "dangling-else" warning.  Let us
/// try to avoid it with the following a bit more ugly trick:
#define output0                                                                        \
    for (int _dummy_i_ = 1; hila::myrank() == 0 && _dummy_i_; --_dummy_i_)             \
    hila::output

// The following disables the "dangling-else" warning, but not needed now
//#if defined(__clang__) || defined(__GNUC__)
//#pragma GCC diagnostic ignored "-Wdangling-else"
//#endif

/// define a class for FFT direction
enum class fft_direction { forward, back };

// trivial template for helping vectorization
template <typename T>
using element = T;

// Backend defs-headers

#if defined(CUDA) || defined(HIP)
#include "plumbing/backend_cuda/defs.h"
#elif defined(AVX)
#include "plumbing/backend_vector/defs.h"
#else
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/backend_cpu/defs.h"
#endif

// this include has to be after the backend defs, because those define hila::random()
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/random.h"

// This contains useful template tools
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/type_tools.h"

#if defined(CUDA) || defined(HIP)
#include "plumbing/backend_cuda/cuda_templated_ops.h"
#endif

// Include some basic functions for real (non-class) vars,
// to help with generic code
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/real_var_ops.h"

// MPI Related functions and definitions
#define MAX_GATHERS 1000

#ifndef USE_MPI

// broadcast does nothing if not MPI
template <typename T>
void broadcast(T &v) {}

template <typename T>
void broadcast_array(T *var, int n) {}

#endif

void initialize_communications(int &argc, char ***argv);
void split_into_sublattices(int rank);
bool is_comm_initialized(void);
void finish_communications();
void abort_communications(int status);

// and print a dashed line
void print_dashed_line(const std::string &txt = {});


#endif
// end include "plumbing/defs.h"---------------------------------

#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/lattice.h"

/***************************************************************/

/* number of primes to be used in factorization */
#define NPRIMES 12
const static int prime[NPRIMES] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};

/* Set up now squaresize and nsquares - arrays
 * Print info to outf as we proceed
 */

void lattice_struct::setup_layout() {
    int nfactors[NPRIMES];
    CoordinateVector nodesiz;

    print_dashed_line();
    output0 << "LAYOUT: lattice size  ";
    foralldir(d) {
        if (d != 0)
            output0 << " x ";
        output0 << size(d);
    }
    output0 << "  =  " << l_volume << " sites\n";
    output0 << "Dividing to " << hila::number_of_nodes() << " nodes\n";

    foralldir(d) if (size(d) % 2 != 0) {
        output0 << "Lattice must be even to all directions (odd size:TODO)\n";
        hila::finishrun();
    }

    // Factorize the node number in primes
    // These factors must be used in slicing the lattice!
    int nn = hila::number_of_nodes();

    int i = nn;
    for (int n = 0; n < NPRIMES; n++) {
        nfactors[n] = 0;
        while (i % prime[n] == 0) {
            i /= prime[n];
            nfactors[n]++;
        }
    }
    if (i != 1) {
        output0 << "Cannot factorize " << nn << " nodes with primes up to "
                << prime[NPRIMES - 1] << '\n';
        hila::finishrun();
    }

    int64_t remainder = l_volume % nn; // remainder = 0 even division

    // strategy: try to increase the box size to one of the directions until rem = 0
    // find the optimal direction to do it
    // Use simple heuristic: take the dim with the least amount of added "ghost sites"

    CoordinateVector nsize;
    int64_t ghosts[NDIM]; // int is too small

    foralldir(d) {
        int64_t cosize = l_volume / size(d);
        int64_t n = size(d);
        while ((n * cosize) % nn != 0)
            n++; // virtual size can be odd
        // now nsize is the new would-be size
        ghosts[d] = (n - size(d)) * cosize;
        nsize[d] = n;
    }

    int mdir = 0;
    bool secondtime = false;
    do {
        // try the division a couple of times, if the 1st fails

        foralldir(j) if (ghosts[mdir] > ghosts[j]) mdir = j;
        // mdir is the direction where we do uneven division (if done)
        // output0 << "MDIR " << mdir << " ghosts mdir " << ghosts[mdir] << " nsize " <<
        // nsize[mdir] << '\n';

        foralldir(i) {
            nodesiz[i] =
                (i == mdir) ? nsize[i] : size(i); // start with ghosted lattice size
            nodes.n_divisions[i] = 1;
        }

        for (int n = NPRIMES - 1; n >= 0; n--)
            for (int i = 0; i < nfactors[n]; i++) {
                // figure out which direction to divide -- start from the largest prime,
                // because we don't want this to be last divisor! (would probably wind up
                // with size 1)

                // find largest divisible dimension of h-cubes - start from last, because
                int msize = 1, dir;
                for (dir = 0; dir < NDIM; dir++)
                    if (nodesiz[dir] > msize && nodesiz[dir] % prime[n] == 0)
                        msize = nodesiz[dir];

                // if one direction with largest dimension has already been
                // divided, divide it again.  Otherwise divide first direction
                // with largest dimension.

                // Switch here to first divide along t-direction, in
                // order to
                // a) minimize spatial blocks
                // b) In sf t-division is cheaper (1 non-communicating slice)

                for (dir = NDIM - 1; dir >= 0; dir--)
                    if (nodesiz[dir] == msize && nodes.n_divisions[dir] > 1 &&
                        nodesiz[dir] % prime[n] == 0)
                        break;

                // If not previously sliced, take one direction to slice
                if (dir < 0)
                    for (dir = NDIM - 1; dir >= 0; dir--)
                        if (nodesiz[dir] == msize && nodesiz[dir] % prime[n] == 0)
                            break;

                if (dir < 0) {
                    // This cannot happen
                    output0 << "CANNOT HAPPEN! in setup_layout_generic.c\n";
                    hila::finishrun();
                }

                // Now slice it
                nodesiz[dir] /= prime[n];
                nodes.n_divisions[dir] *= prime[n];
            }

        // now check that the div makes sens
        bool fail = false;
        foralldir(dir) if (nodesiz[dir] < 3) fail =
            true; // don't allow nodes of size 1 or 2
        if (fail && !secondtime) {
            secondtime = true;
            ghosts[mdir] =
                (1ULL << 62); // this short-circuits direction mdir, some other taken next
        } else if (fail) {
            output0 << "Could not successfully lay out the lattice with " << hila::number_of_nodes()
                    << " nodes\n";
            hila::finishrun();
        }

    } while (secondtime);

    // set up struct nodes variables
    nodes.number = hila::number_of_nodes();
    foralldir(dir) {
        nodes.divisors[dir].resize(nodes.n_divisions[dir] + 1);
        // Node divisors: note, this MUST BE compatible with
        // node_rank in lattice.cpp
        // to be sure, we use naively the same method than in node_rank
        // last element will be size(dir), for convenience
        int n = -1;
        for (int i = 0; i <= size(dir); i++)
            if ((i * nodes.n_divisions[dir]) / size(dir) != n) {
                ++n;
                nodes.divisors[dir][n] = i;
            }
        // output0 << "Divisors ";
        // for (int i=0;i<nodes.n_divisions[dir]; i++) output0 << nodes.divisors[dir][i]
        // << " "; output0 << '\n';
    }

    // Now division done - check how good it is
    int ghost_slices = nsize[mdir] - size(mdir);
    if (ghost_slices > 0) {
        output0 << "\nUsing uneven node division to direction " << mdir << ":\n";
        output0 << "Lengths: " << nodes.n_divisions[mdir] - ghost_slices << " * ("
                << nodesiz[mdir] << " sites) + " << ghost_slices << " * ("
                << nodesiz[mdir] - 1 << " sites)\n";
        output0 << "Divisions: ";
        for (int i = 0; i < nodes.n_divisions[mdir]; i++) {
            if (i > 0)
                output0 << " - ";
            output0 << nodes.divisors[mdir][i + 1] - nodes.divisors[mdir][i];
        }
        output0 << "\nFilling efficiency: " << (100.0 * size(mdir)) / nsize[mdir]
                << "%\n";

        if (ghost_slices > nodes.n_divisions[mdir] / 2)
            output0 << "NOTE: number of smaller nodes > large nodes \n";
    }

    // this was hila::number_of_nodes() > 1
    if (1) {
        output0 << "\nSites on node: ";
        foralldir(dir) {
            if (dir > 0)
                output0 << " x ";
            if (dir == mdir && ghost_slices > 0)
                output0 << '(' << nodesiz[dir] - 1 << '-' << nodesiz[dir] << ')';
            else
                output0 << nodesiz[dir];
        }
        int ns = 1;
        foralldir(dir) ns *= nodesiz[dir];
        if (ghost_slices > 0) {
            int ns2 = ns * (nodesiz[mdir] - 1) / nodesiz[mdir];
            output0 << "  =  " << ns2 << " - " << ns << '\n';
        } else {
            output0 << "  =  " << ns << '\n';
        }

        output0 << "Processor layout: ";
        foralldir(dir) {
            if (dir > 0)
                output0 << " x ";
            output0 << nodes.n_divisions[dir];
        }
        output0 << "  =  " << hila::number_of_nodes() << " nodes\n";
    }

#ifdef USE_MPI
    // For MPI, remap the nodes for periodic torus
    // in the desired manner
    // we have at least 2 options:
    // map_node_layout_trivial.c
    // map_node_layout_block2.c - for 2^n n.n. blocks

    nodes.create_remap();

#endif

    print_dashed_line();
}
