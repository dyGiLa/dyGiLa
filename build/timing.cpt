// File generated by hilapp at Thu Mar 10 09:10:11 2022
// Git version: e3ba0735
// cmd: ../../HILA/hila/hilapp/bin/hilapp -I/opt/shared/openmpi/1.8.2/include 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/include/c++/9.3.0 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/../../../../include/c++/9.3.0/x86_64-pc-linux-gnu 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/../../../../include/c++/9.3.0/backward 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/include 
//        -I/usr/local/include -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/include 
//        -I/cluster/tufts/hpc/tools/spack/linux-rhel7-sandybridge/gcc-8.4.0/gcc-9.3.0-hv7dnzblbdfkadid4q76jcdpq5sfyfkb/lib/gcc/x86_64-pc-linux-gnu/9.3.0/include-fixed 
//        -I/usr/include -I/opt/shared/openmpi/1.8.2/include -I/opt/shared/fftw/3.3.2/include/ 
//        -DUSE_MPI -I../../HILA/hila/hilapp/clang_include -DNDIM=3 
//        -DUSE_MPI -I/opt/shared/fftw/3.3.2/include/ -I../../HILA/hila/libraries 
//        -I../../HILA/hila/libraries/plumbing -DGIT_SHA_VALUE=b1aa3587 
//        ../../HILA/hila/libraries/plumbing/timing.cpp -o build/timing.cpt 
//        


#include <time.h>
#include <chrono>

// start include "timing.h"---------------------------------
#ifndef TIMING_H
#define TIMING_H

// start include "plumbing/defs.h"---------------------------------
#ifndef DEFS_H_
#define DEFS_H_

// This gives us math constants, e.g. M_PI etc.
#define _USE_MATH_DEFINES

// Useful global definitions here -- this file should be included by (almost) all others

#include <iostream>
#include <array>
#include <vector>
#include <assert.h>
#include <sstream>
// #include <math.h>
#include <type_traits>
#include <cmath>


#ifdef USE_MPI
#ifdef HILAPP
// Removed by hilapp"/cluster/home/alopez07/HILA/hila/libraries/plumbing/hilapp_mpi.h"
#else
#include <mpi.h>
#endif
#endif

// Read in Makefile tunable parameters first
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/params.h"

#ifdef HILAPP
// Removed by hilapp
#endif

#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/mersenne.h"
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/memalloc.h" // memory allocator
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/timing.h"


/// Define __restrict__?  It is non-standard but supported by most (all?) compilers.
/// ADD HERE GUARD FOR THOSE WHICH DO not HAVE IT
#define RESTRICT __restrict__
// #ifndef CUDA
// #define RESTRICT __restrict__
// #else
// #define RESTRICT // disabled here
// #endif


// This below declares "out_only" -qualifier.  It is empty on purpose. Do not remove!
#define out_only
// out_only for methods tells hilapp that the base variable original value is not
// needed: class C {
//    int set() out_only { .. }
// };
// indicates that a.set(); does not need original value of a.
// Can also be used in function arguments:
//    int func( out_only double & p, ..);

// Defined empty on purpose, same as above!
#define const_function
// const_function does not change the base variable, but can return a (non-const)
// reference. Needed typically for access operators for loop extern variables:
//     class v {
//         double c[N];
//         double & e(const int i) const_function { return c[i]; }
//     };
//
//     v vv;
//     Field<v>  f;
//     onsites(ALL) { f[X].e(0) += vv.e(0); }
// This would not work without const_function, because vv.e(1) might modify loop
// extern variable vv, which is not allowed.  If method is marked "const",
// then the assignment would not work.
//
// const_function is weaker than const.


// text output section -- defines also output0, which writes from node 0 only
namespace hila {

/// this is our default output file stream
extern std::ostream output;
/// this is just a hook to store output file, if it is in use
extern std::ofstream output_file;

// about_to_finish becomes true at the end.  Signals that
// better not rely on MPI or existence of objects any more.
extern bool about_to_finish;

// check_input is used to notify that we're just checking the
// input values and will exit before fields are allocated.
extern bool check_input;
extern int check_with_nodes;

// optional input filename
extern const char *input_file;

void initialize(int argc, char **argv);
void finishrun();
void terminate(int status);
void error(const std::string &msg);
void error(const char *msg);


/// rank of this node
int myrank();
/// how many nodes there are
int number_of_nodes();
/// synchronize mpi
void synchronize();


} // namespace hila

// The logger uses hila::myrank, so it cannot be included on top
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/logger.h"
namespace hila {
/// Now declare the logger
extern logger_class log;
} // namespace hila

/// We want to define ostream
///     "output0 << stuff;"
/// which is done only by rank 0.
/// This is hacky but easy.  Probably should be done without #define.
/// Do this through else-branch in order to avoid if-statement problems.
/// #define output0 if (hila::myrank() != 0) {} else hila::output
///
/// Above #define can trigger "dangling-else" warning.  Let us
/// try to avoid it with the following a bit more ugly trick:
#define output0                                                                        \
    for (int _dummy_i_ = 1; hila::myrank() == 0 && _dummy_i_; --_dummy_i_)             \
    hila::output

// The following disables the "dangling-else" warning, but not needed now
//#if defined(__clang__) || defined(__GNUC__)
//#pragma GCC diagnostic ignored "-Wdangling-else"
//#endif

/// define a class for FFT direction
enum class fft_direction { forward, back };

// trivial template for helping vectorization
template <typename T>
using element = T;

// Backend defs-headers

#if defined(CUDA) || defined(HIP)
#include "plumbing/backend_cuda/defs.h"
#elif defined(AVX)
#include "plumbing/backend_vector/defs.h"
#else
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/backend_cpu/defs.h"
#endif

// this include has to be after the backend defs, because those define hila::random()
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/random.h"

// This contains useful template tools
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/type_tools.h"

#if defined(CUDA) || defined(HIP)
#include "plumbing/backend_cuda/cuda_templated_ops.h"
#endif

// Include some basic functions for real (non-class) vars,
// to help with generic code
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/real_var_ops.h"

// MPI Related functions and definitions
#define MAX_GATHERS 1000

#ifndef USE_MPI

// broadcast does nothing if not MPI
template <typename T>
void broadcast(T &v) {}

template <typename T>
void broadcast_array(T *var, int n) {}

#endif

void initialize_communications(int &argc, char ***argv);
void split_into_sublattices(int rank);
bool is_comm_initialized(void);
void finish_communications();
void abort_communications(int status);

// and print a dashed line
void print_dashed_line(const std::string &txt = {});


#endif
// end include "plumbing/defs.h"---------------------------------


namespace hila {

////////////////////////////////////////////////////////////////
/// This file defines timer class and other timing related utilities

struct timer_value {
    double time;   // time accumulated in this timer (in sec)
    int64_t count; // how many times this timer has been used (start - stop interval)
};

////////////////////////////////////////////////////////////////
///
/// Timers are used to time recurring events.  Usage:
///
///         static timer loop_timer("Loop");
///
///         loop_timer.start();
///            < timed section >
///         loop_timer.stop();
///
/// All timer values are automatically reported on program exit (hila::finishrun calls
/// report_timers())
///
/// Timer can be reset with
///       loop_timer.reset();
///
/// Timer value can be inquired with
///       timer_value tval = loop_timer.value();
/// where timer_value is a struct defined below.
///
///
/// Other time related functions:
///       double gettime();                    - returns the time in seconds from program
///       start void timestamp("message");           - prints msg + current date+time +
///       time from start
///
///       void setup_timelimit(long seconds);  - sets the cpu time limit (see
///       time_to_exit()) bool time_to_exit();                 - to be called periodically
///       at a suitable spot in
///                                              the program; returns true if the program
///                                              should exit now.
///
////////////////////////////////////////////////////////////////



class timer {
  private:
    double t_start, t_total;
    int64_t count; // need more than 32 bits
    std::string label;
    bool is_on, is_error;

  public:
    // initialize timer to this timepoint
    timer() { init(nullptr); }
    timer(const char *tag) { init(tag); }

    ~timer() { remove(); }

    void init(const char *tag);
    void remove();
    void reset();
    double start();
    double stop();
    void error();
    void report(bool print_not_timed = false);

    timer_value value();
};

void report_timers();

//////////////////////////////////////////////////////////////////
// Prototypes
//////////////////////////////////////////////////////////////////

double gettime();
void inittime();

bool time_to_exit();
void setup_timelimit(long seconds);

void timestamp(const char *msg);


} // namespace hila

#endif /* timing */
// end include "timing.h"---------------------------------


//////////////////////////////////////////////////////////////////
/// Time related routines (runtime - timing - timelimit)
/// Check timing.h for details
//////////////////////////////////////////////////////////////////

#ifdef USE_MPI
#include "/cluster/home/alopez07/HILA/hila/libraries/plumbing/com_mpi.h"
#endif

namespace hila {

// This stores the start time of the program
static double start_time = -1.0;

/////////////////////////////////////////////////////////////////
/// Timer routines - for high-resolution event timing
/////////////////////////////////////////////////////////////////

// store all timers in use
std::vector<timer *> timer_list = {};

// initialize timer to this timepoint
void timer::init(const char *tag) {
    if (tag != nullptr) label = tag;
    reset();
    // Store it on 1st use!
}

// remove the timer also from the list
void timer::remove() {
    for (auto it = timer_list.begin(); it != timer_list.end(); ++it) {
        if (*it == this) {
            timer_list.erase(it);
            return;
        }
    }
}

void timer::reset() {
    t_start = t_total = 0.0;
    count = 0;
    is_on = is_error = false;
}

void timer::error() {
    if (!is_error) {
        output0 << " **** Timer '" << label
                << "' error, unbalanced start/stop.  Removing from statistics\n";
    }
    is_error = true;
}

double timer::start() {
    if (is_on) error();
    is_on = true;

    // Move storing the timer ptr here, because if timer is initialized
    // in the global scope the timer_list is possibly initialized later!
    if (count == 0) {
        timer_list.push_back(this);
    }

    t_start = hila::gettime();
    return t_start;
}

double timer::stop() {
    if (!is_on) error();
    is_on = false;

    double e = hila::gettime();
    t_total += (e - t_start);
    count++;
    return e;
}

timer_value timer::value() {
    timer_value r;
    r.time = t_total;
    r.count = count;
    return r;
}

void timer::report(bool print_not_timed) {
    if (hila::myrank() == 0) {
        char line[202];

        // time used during the counter activity
        double ttime = gettime();
        if (count > 0 && !is_error) {
            if (t_total / count > 0.1) {
                std::snprintf(line, 200, "%-20s: %14.3f %14ld %10.3f s  %8.4f\n",
                              label.c_str(), t_total, (long)count, t_total / count,
                              t_total / ttime);
            } else if (t_total / count > 1e-4) {
                std::snprintf(line, 200, "%-20s: %14.3f %14ld %10.3f ms %8.4f\n",
                              label.c_str(), t_total, (long)count,
                              1e3 * t_total / count, t_total / ttime);
            } else {
                std::snprintf(line, 200, "%-20s: %14.3f %14ld %10.3f us %8.4f\n",
                              label.c_str(), t_total, (long)count,
                              1e6 * t_total / count, t_total / ttime);
            }
            hila::output << line;
        } else if (!is_error && print_not_timed) {
            std::snprintf(line, 200, "%-20s: no timed calls made\n", label.c_str());
            hila::output << line;
        } else if (is_error) {
            std::snprintf(line, 200, "%-20s: error:unbalanced start/stop\n",
                          label.c_str());
            hila::output << line;
        }
    }
}

void report_timers() {
    if (hila::myrank() == 0) {
        if (timer_list.size() > 0) {
            hila::output << "TIMER REPORT:             total(sec)          calls     "
                            "time/call  fraction\n";
            hila::output
                << "------------------------------------------------------------"
                   "---------------\n";

            for (auto tp : timer_list) {
                tp->report();
            }

            hila::output
                << "------------------------------------------------------------"
                   "---------------\n";
        } else {
            hila::output << "No timers defined\n";
        }
    }
}

/////////////////////////////////////////////////////////////////
/// Use clock_gettime() to get the accurate time
/// (alternative: use gettimeofday()  or MPI_Wtime())
/// gettime returns the time in secs since program start

double gettime() {
    struct timespec tp;

    if (start_time == -1.0) inittime();

    clock_gettime(CLOCK_MONOTONIC, &tp);
    return (((double)tp.tv_sec - start_time) + 1.0e-9 * (double)tp.tv_nsec);
}

void inittime() {
    if (start_time == -1.0) {
        start_time = 0.0;
        start_time = gettime();
    }
}

//////////////////////////////////////////////////////////////////
/// Routines for checking remaining cpu-time
/// time_to_exit() is called periodically on a point where exit can be done.
/// It uses the max of the time intervals for the estimate for one further round.
/// If not enough time returns true, else false
///

static double timelimit = 0;

void setup_timelimit(long seconds) {
    timelimit = (double)seconds;
}

bool time_to_exit() {
    static double max_interval = 0.0;
    static double previous_time = 0.0;
    bool finish;

    // if no time limit set
    if (timelimit == 0.0) return false;

    if (hila::myrank() == 0) {
        double this_time = gettime();
        if (this_time - previous_time > max_interval)
            max_interval = this_time - previous_time;
        previous_time = this_time;

        // Give 5 min margin for the exit - perhaps needed for writing etc.
        if (timelimit - this_time < max_interval + 5 * 60.0)
            finish = true;
        else
            finish = false;

        hila::output << "TIMECHECK: " << this_time << "s used, "
                     << timelimit - this_time << "s remaining\n";
        if (finish) hila::output << "CPU TIME LIMIT, EXITING THE PROGRAM\n";
    }
    broadcast(finish);
    return finish;
}

/*****************************************************
 * Time stamp
 */

void timestamp(const char *msg) {
    if (hila::myrank() == 0) {
        std::time_t ct = std::time(NULL);
        if (msg != NULL) hila::output << msg;
        std::string d = ctime(&ct);
        d.resize(d.size() - 1); // take away \n at the end
        hila::output << " -- date " << d << "  run time " << hila::gettime() << "s\n";
    }
}

} // namespace hila
